---
// TableOfContents component
// Enhanced with auto-collapsing sections and smooth animations
---

<div id="toc-container" class="fixed left-8 top-1/2 transform -translate-y-1/2 z-10 hidden xl:block">
  <!-- Desktop TOC - same as before -->
  <div class="bg-bg-card border border-border rounded-lg p-4 max-w-xs shadow-lg backdrop-blur-sm">
    <div class="flex items-center justify-between mb-3">
      <h3 class="text-sm font-semibold text-text">Contents</h3>
      <button 
        id="toc-main-toggle" 
        class="text-text-muted hover:text-text transition-colors duration-200 p-1 rounded hover:bg-bg-soft"
        aria-label="Toggle table of contents"
      >
        <svg id="toc-main-chevron" class="w-4 h-4 transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
        </svg>
      </button>
    </div>
    <nav id="toc-nav" class="space-y-1 transition-all duration-300 ease-in-out overflow-hidden">
      <!-- TOC will be generated here by JavaScript -->
    </nav>
  </div>
</div>

<!-- Mobile TOC Toggle Button -->
<button 
  id="mobile-toc-toggle" 
  class="fixed bottom-4 right-4 z-20 xl:hidden bg-bg-card border border-border rounded-full p-3 shadow-lg backdrop-blur-sm hover:bg-bg-soft transition-all duration-200 hover:scale-105"
  aria-label="Toggle table of contents"
>
  <svg class="w-5 h-5 text-text" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h8m-8 6h16"></path>
  </svg>
</button>

<!-- Mobile TOC Sidebar -->
<div 
  id="mobile-toc-overlay" 
  class="fixed inset-0 z-30 xl:hidden opacity-0 pointer-events-none transition-opacity duration-300 ease-in-out"
>
  <!-- Background overlay -->
  <div class="absolute inset-0 bg-black/50 backdrop-blur-sm"></div>
  
  <!-- Sidebar -->
  <div 
    id="mobile-toc-sidebar"
    class="absolute left-0 top-0 bottom-0 w-80 max-w-[80vw] bg-bg-card border-r border-border shadow-2xl transform -translate-x-full transition-transform duration-300 ease-in-out overflow-hidden"
  >
    <!-- Header -->
    <div class="flex items-center justify-between p-4 border-b border-border bg-bg-soft/50 backdrop-blur-sm">
      <h3 class="text-lg font-semibold text-text">Table of Contents</h3>
      <button 
        id="mobile-toc-close" 
        class="text-text-muted hover:text-text transition-colors duration-200 p-2 hover:bg-bg rounded-full"
        aria-label="Close table of contents"
      >
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>
    
    <!-- Content -->
    <nav id="mobile-toc-nav" class="p-4 overflow-y-auto h-full pb-20">
      <!-- Mobile TOC will be generated here by JavaScript -->
    </nav>
  </div>
</div>

<script>
  interface TOCItem {
    element: HTMLHeadingElement;
    level: number;
    text: string;
    id: string;
    children: TOCItem[];
    parent?: TOCItem;
  }

  // Generate hierarchical table of contents from headings
  function generateTOC() {
    const tocNav = document.getElementById('toc-nav')
    const mobileTocNav = document.getElementById('mobile-toc-nav')
    const tocContainer = document.getElementById('toc-container')
    const mobileTocToggle = document.getElementById('mobile-toc-toggle')
    const headings = document.querySelectorAll('article h1, article h2, article h3, article h4, article h5, article h6') as NodeListOf<HTMLHeadingElement>
    
    if (headings.length === 0) {
      tocContainer?.style.setProperty('display', 'none')
      mobileTocToggle?.style.setProperty('display', 'none')
      return
    }

    tocNav!.innerHTML = ''
    mobileTocNav!.innerHTML = ''
    
    // Build hierarchical structure
    const tocItems: TOCItem[] = []
    const stack: TOCItem[] = []
    
    headings.forEach((heading, index) => {
      // Create an ID if the heading doesn't have one
      if (!heading.id) {
        heading.id = `heading-${index}`
      }
      
      const level = parseInt(heading.tagName.charAt(1))
      const text = heading.textContent || ''
      
      const item: TOCItem = {
        element: heading,
        level,
        text,
        id: heading.id,
        children: []
      }
      
      // Find the right parent
      while (stack.length > 0 && stack[stack.length - 1].level >= level) {
        stack.pop()
      }
      
      if (stack.length > 0) {
        const parent = stack[stack.length - 1]
        parent.children.push(item)
        item.parent = parent
      } else {
        tocItems.push(item)
      }
      
      stack.push(item)
    })
    
    // Render the TOC for both desktop and mobile
    renderTOCItems(tocItems, tocNav!)
    renderMobileTOCItems(tocItems, mobileTocNav!)
  }

  // Render mobile TOC (simplified, always expanded)
  function renderMobileTOCItems(items: TOCItem[], container: HTMLElement, depth = 0) {
    items.forEach(item => {
      const link = document.createElement('a')
      link.href = `#${item.id}`
      link.textContent = item.text
      link.className = `block text-text-muted hover:text-accent transition-colors duration-200 py-3 border-l-2 border-transparent hover:border-accent rounded-r px-3 hover:bg-bg-soft/50 ${
        depth === 0 ? 'font-semibold text-base' : 
        depth === 1 ? 'pl-6 text-sm' : 
        depth === 2 ? 'pl-9 text-sm' : 
        depth === 3 ? 'pl-12 text-xs' : 'pl-15 text-xs'
      }`
      
      link.addEventListener('click', (e) => {
        e.preventDefault()
        scrollToHeading(item.id)
        
        // Close mobile sidebar with animation
        const mobileOverlay = document.getElementById('mobile-toc-overlay')
        const mobileSidebar = document.getElementById('mobile-toc-sidebar')
        
        mobileOverlay?.classList.remove('opacity-100')
        mobileOverlay?.classList.add('opacity-0')
        mobileSidebar?.classList.remove('translate-x-0')
        mobileSidebar?.classList.add('-translate-x-full')
        
        setTimeout(() => {
          mobileOverlay?.classList.add('pointer-events-none')
        }, 300)
      })
      
      container.appendChild(link)
      
      // Render children (always visible on mobile)
      if (item.children.length > 0) {
        renderMobileTOCItems(item.children, container, depth + 1)
      }
    })
  }

  // Setup mobile TOC functionality
  function setupMobileTOC() {
    const mobileToggle = document.getElementById('mobile-toc-toggle')
    const mobileOverlay = document.getElementById('mobile-toc-overlay')
    const mobileSidebar = document.getElementById('mobile-toc-sidebar')
    const mobileClose = document.getElementById('mobile-toc-close')
    
    let isOpen = false
    
    // Open sidebar
    mobileToggle?.addEventListener('click', () => {
      if (!isOpen) {
        isOpen = true
        mobileOverlay?.classList.remove('pointer-events-none')
        
        // Animate in
        requestAnimationFrame(() => {
          mobileOverlay?.classList.remove('opacity-0')
          mobileOverlay?.classList.add('opacity-100')
          mobileSidebar?.classList.remove('-translate-x-full')
          mobileSidebar?.classList.add('translate-x-0')
        })
      }
    })
    
    // Close sidebar
    const closeSidebar = () => {
      if (isOpen) {
        isOpen = false
        
        // Animate out
        mobileOverlay?.classList.remove('opacity-100')
        mobileOverlay?.classList.add('opacity-0')
        mobileSidebar?.classList.remove('translate-x-0')
        mobileSidebar?.classList.add('-translate-x-full')
        
        // Remove pointer events after animation
        setTimeout(() => {
          mobileOverlay?.classList.add('pointer-events-none')
        }, 300)
      }
    }
    
    mobileClose?.addEventListener('click', closeSidebar)
    
    // Close on overlay click (but not sidebar click)
    mobileOverlay?.addEventListener('click', (e) => {
      if (e.target === mobileOverlay || (!mobileSidebar?.contains(e.target as Node) && e.target !== mobileSidebar)) {
        closeSidebar()
      }
    })
    
    // Close on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && isOpen) {
        closeSidebar()
      }
    })
  }

  function renderTOCItems(items: TOCItem[], container: HTMLElement, depth = 0) {
    items.forEach(item => {
      const itemContainer = document.createElement('div')
      itemContainer.className = 'toc-item'
      
      const linkContainer = document.createElement('div')
      linkContainer.className = `toc-link-container flex items-center cursor-pointer rounded px-2 py-1 transition-all duration-200 hover:bg-bg-soft group ${
        depth === 0 ? '' : 
        depth === 1 ? 'ml-3' : 
        depth === 2 ? 'ml-6' : 
        depth === 3 ? 'ml-9' : 'ml-12'
      }`
      
      // Expand/collapse button (only if has children)
      if (item.children.length > 0) {
        const expandBtn = document.createElement('button')
        expandBtn.className = 'toc-expand-btn mr-2 text-text-muted hover:text-accent transition-all duration-200'
        expandBtn.innerHTML = `
          <svg class="w-3 h-3 transform transition-transform duration-200 rotate-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
          </svg>
        `
        linkContainer.appendChild(expandBtn)
      } else {
        // Add spacing for items without children
        const spacer = document.createElement('div')
        spacer.className = 'w-5 mr-2'
        linkContainer.appendChild(spacer)
      }
      
      // The actual link
      const link = document.createElement('a')
      link.href = `#${item.id}`
      link.textContent = item.text
      link.className = `flex-1 text-sm text-text-muted hover:text-accent transition-colors duration-200 border-l-2 border-transparent hover:border-accent pl-2 ${
        item.level === 1 ? 'font-semibold' : ''
      }`
      
      linkContainer.appendChild(link)
      itemContainer.appendChild(linkContainer)
      
      // Children container (initially collapsed except for first level)
      if (item.children.length > 0) {
        const childrenContainer = document.createElement('div')
        childrenContainer.className = `toc-children overflow-hidden transition-all duration-300 ease-in-out`
        
        // Set initial state
        if (depth === 0) {
          childrenContainer.style.maxHeight = 'none'
          childrenContainer.style.opacity = '1'
        } else {
          childrenContainer.style.maxHeight = '0px'
          childrenContainer.style.opacity = '0'
        }
        
        renderTOCItems(item.children, childrenContainer, depth + 1)
        itemContainer.appendChild(childrenContainer)
        
        // Toggle functionality - make entire row clickable
        linkContainer.addEventListener('click', (e) => {
          e.preventDefault()
          toggleSection(itemContainer, item.id)
        })
      } else {
        // For leaf nodes, only the link part should navigate
        link.addEventListener('click', (e) => {
          e.preventDefault()
          e.stopPropagation()
          scrollToHeading(item.id)
        })
      }
      
      container.appendChild(itemContainer)
    })
  }

  function toggleSection(itemContainer: HTMLElement, headingId: string) {
    const expandBtn = itemContainer.querySelector('.toc-expand-btn svg') as SVGElement
    const childrenContainer = itemContainer.querySelector('.toc-children') as HTMLElement
    
    if (!childrenContainer || !expandBtn) return
    
    const isExpanded = childrenContainer.style.maxHeight !== '0px'
    
    if (isExpanded) {
      // Collapse - first set to current height, then animate to 0
      const currentHeight = childrenContainer.scrollHeight
      childrenContainer.style.maxHeight = currentHeight + 'px'
      childrenContainer.offsetHeight // Force reflow
      
      requestAnimationFrame(() => {
        childrenContainer.style.maxHeight = '0px'
        childrenContainer.style.opacity = '0'
        expandBtn.style.transform = 'rotate(0deg)'
      })
    } else {
      // Expand - set to scrollHeight and animate opacity
      const targetHeight = childrenContainer.scrollHeight
      childrenContainer.style.maxHeight = targetHeight + 'px'
      childrenContainer.style.opacity = '1'
      expandBtn.style.transform = 'rotate(90deg)'
      
      // After animation, set to 'none' so it can grow if content changes
      setTimeout(() => {
        if (childrenContainer.style.maxHeight !== '0px') {
          childrenContainer.style.maxHeight = 'none'
        }
      }, 300)
      
      // Also scroll to the heading
      scrollToHeading(headingId)
    }
  }

  function scrollToHeading(headingId: string) {
    const target = document.getElementById(headingId)
    if (target) {
      target.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'start',
        inline: 'nearest'
      })
      // Update URL without triggering scroll
      history.replaceState(null, '', `#${headingId}`)
    }
  }

  // Main toggle functionality
  function setupMainTOCToggle() {
    const toggle = document.getElementById('toc-main-toggle')
    const nav = document.getElementById('toc-nav')
    const chevron = document.getElementById('toc-main-chevron')
    let isCollapsed = false
    
    toggle?.addEventListener('click', () => {
      isCollapsed = !isCollapsed
      if (nav && chevron) {
        if (isCollapsed) {
          nav.style.maxHeight = '0px'
          nav.style.opacity = '0'
          chevron.style.transform = 'rotate(-90deg)'
        } else {
          nav.style.maxHeight = '70vh'
          nav.style.opacity = '1'
          chevron.style.transform = 'rotate(0deg)'
        }
      }
    })
  }

  // Enhanced current section highlighting with better tracking
  function highlightCurrentSection() {
    const headings = document.querySelectorAll('article h1, article h2, article h3, article h4, article h5, article h6') as NodeListOf<HTMLHeadingElement>
    const links = document.querySelectorAll('#toc-nav a') as NodeListOf<HTMLAnchorElement>
    
    const observer = new IntersectionObserver((entries) => {
      // Find the topmost visible heading
      let currentHeading: HTMLHeadingElement | null = null
      let currentTop = Infinity
      
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const rect = entry.boundingClientRect
          if (rect.top < currentTop && rect.top >= 0) {
            currentTop = rect.top
            currentHeading = entry.target as HTMLHeadingElement
          }
        }
      })
      
      if (currentHeading) {
        const id = currentHeading.id
        // Remove active class from all links
        links.forEach(link => {
          link.classList.remove('text-accent', 'border-accent', 'font-medium')
          link.classList.add('text-text-muted', 'border-transparent')
        })
        
        // Add active class to current link
        const activeLink = document.querySelector(`#toc-nav a[href="#${id}"]`) as HTMLAnchorElement
        if (activeLink) {
          activeLink.classList.remove('text-text-muted', 'border-transparent')
          activeLink.classList.add('text-accent', 'border-accent', 'font-medium')
          
          // Auto-expand parent sections if needed
          let parent = activeLink.closest('.toc-item')
          while (parent) {
            const parentContainer = parent.parentElement?.closest('.toc-children') as HTMLElement
            if (parentContainer && parentContainer.style.maxHeight === '0px') {
              const parentItem = parentContainer.parentElement
              if (parentItem) {
                const expandBtn = parentItem.querySelector('.toc-expand-btn svg') as SVGElement
                if (expandBtn) {
                  const targetHeight = parentContainer.scrollHeight
                  parentContainer.style.maxHeight = targetHeight + 'px'
                  parentContainer.style.opacity = '1'
                  expandBtn.style.transform = 'rotate(90deg)'
                  
                  // Set to 'none' after animation
                  setTimeout(() => {
                    if (parentContainer.style.maxHeight !== '0px') {
                      parentContainer.style.maxHeight = 'none'
                    }
                  }, 300)
                }
              }
            }
            parent = parentContainer?.parentElement?.closest('.toc-item') || null
          }
        }
      }
    }, {
      rootMargin: '-10% 0% -85% 0%',
      threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
    })
    
    headings.forEach(heading => observer.observe(heading))
  }

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    generateTOC()
    setupMainTOCToggle()
    setupMobileTOC()
    highlightCurrentSection()
  })
</script>

<style>
  #toc-container {
    max-height: 80vh;
  }
  
  #toc-nav {
    scrollbar-width: thin;
    scrollbar-color: rgba(163, 191, 250, 0.3) transparent;
    max-height: 70vh;
  }
  
  #toc-nav::-webkit-scrollbar {
    width: 4px;
  }
  
  #toc-nav::-webkit-scrollbar-track {
    background: transparent;
  }
  
  #toc-nav::-webkit-scrollbar-thumb {
    background-color: rgba(163, 191, 250, 0.3);
    border-radius: 2px;
  }
  
  .toc-children {
    transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out;
  }
  
  .toc-link-container:hover {
    transform: translateX(2px);
  }
</style>